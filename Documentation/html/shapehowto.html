<HTML>
<HEAD>
<TITLE>Graphviz custom shapes</TITLE>
</HEAD>

<body bgcolor="#ffffff" leftmargin=0
topmargin=0 marginheight=0 marginwidth=0 link="#339999" vlink="#888888">

<H3> Graphviz custom shapes </H3>

As alluded to in the
<A HREF=dotguide.pdf>
dot user's guide</A>,
there are several ways to incorporate
custom shapes.
At this point, they either must be in PostScript or image files,
or you'll need to modify the <A HREF=download.html>source code</A>.

A serious problem is that you can't make custom shapes that work
across all the drivers and the interactive front ends such as <tt>dotty</tt>
or <tt>Grappa</tt>.   At least SVG has interactive renderers, 
and PostScript can be translated to PDF which also has some
interactive features.  Improving the architecture of the graphics
drivers is an ongoing project of ours.

<h4> <A NAME=ext_image>External image files</A> </h4>
If using SVG (<TT>-Tsvg</TT>), PostScript (<TT>-Tps</TT>,<TT>-Tps2</TT>) 
or one of the raster
formats (<TT>-Tgif</TT>, <TT>-Tpng</TT>, or <TT>-Tjpg</TT>),
you can load certain images (e.g. pictures) by file name into nodes. 
For example:
<pre>
   yournode [shapefile="yourface.gif"];
</pre>
indicates the contents of the node are given in 
the GIF file <TT>yourface.gif</TT>. The 
<A HREF=http://www.research.att.com/~erg/graphviz/info/attrs.html#d:shapefile>shapefile</A>
attribute specifies which file to use.
<P>
<I>
NOTE: In versions before 11 March 2006, in particular, 1.12 graphviz and earlier,
it is necessary to also set the attribute <TT>shape=custom</TT>.
</I>
<P>
With <TT>-Tsvg</TT>, shapefile must give the name of a file containing
a GIF, PNG or JPEG bitmap file. 
Note that the file's contents are not copied into
the SVG output, only the files name. Thus, for Graphviz SVG output to
display correctly, the image file must be available to the SVG viewer.
<P>
With PostScript, shapefile must give the name of a file containing
encapsulated PostScript or a bitmap. 
The contents are copied into the output file.
Note that encapsulated PostScript will only be copied in once.
The restrictions on the contents of the shapefile are the same as
those specified below under
<A HREF=#ext_ps>External PostScript files</A>.
<P>
In the raster formats (based on Boutell's <tt>libgd</tt>),
<TT>shapefile</TT> is a file name containing a bitmap image.
The file is opened and 
copied (and possibly scaled) into the output drawing.
<P>
This code is still preliminary, and we have noted some problems
with color quantization in indexed color map management that we
are trying to understand and correct. (You can use <TT>-Gtruecolor=1</TT>
to try a 32 bit internal canvas as an alternative, but we have observed
fuzziness (lossiness?) in the images.)
<P>
When the software is used as a web server, access to image files is
more restrictive. See <A HREF=d:GV_FILE_PATH>GV_FILE_PATH</A> and 
<A HREF=d:SERVER_NAME>SERVER_NAME</A>.

<h4> <A NAME=ext_ps>External PostScript files </A></h4>
If using the PostScript driver (<TT>-Tps</TT>) you can
import node shapes as external PostScript files such as EPS
(Encapsulated PostScript).  At a minimum, the external file
must have a valid <TT>BoundingBox</TT> header and not do
drastic things to the graphics state since we don't install
a wrapper for example to inhibit <TT>showpage</TT>.
<P>
To import an external PostScript file, set the <TT>shape</TT>
and <TT>shapefile</TT> attributes as shown here:

<dfn><TT>
	somenode  [shape=epsf, shapefile="yourfile.ps" ];
</TT></dfn>

An EPSF shape is always clipped to its bounding box.
<P>
The use of <tt>[shape=epsf, shapefile="yourfile.ps" ]</tt> is largely 
superceded by the mechanism described in the previous section, using
<tt>[shapefile="yourfile.ps" ]</tt>.

<h4><A NAME=psprocs> External PostScript procedures</A></h4>
If using the PostScript driver (<TT>dot -Tps</TT>), you can define
a PostScript procedure for shape drawing.  The procedure must
be able to draw variable-sized shapes.  A file containing
the definition can be loaded as a command line argument using
the <TT>-l</TT> flag:
<PRE><TT>
	dot  -Tps -l yourPS.ps  file.dot -o file.ps
</TT></PRE>
In the graph file, invoke the shape like this:

<PRE><TT>
	somenode [shape=yourshape]
</TT></PRE>

In <TT>file.ps</TT>, for non-filled nodes,
the procedure for <TT>yourshape</TT> will be called like this:

<PRE><TT>
[ 54 36 0 36 0 0 54 0 54 36 ]  4 false yourshape
</TT></PRE>

where the current color is the node's pencolor.
The array contains the shape's bounding polygon, with the first
point repeated at the end, followed by the number
of points. At present, the shape is always a rectangle. From left to right, the
points in the array always go counterclockwise, starting with the
upper-right vertex. The boolean value after the number of vertices,
here <TT>false</TT>, is the value of the
node's "fill" attribute.  The coordinates are absolute canvas coordinates.
<P>
For nodes with <TT>fill=true</TT>, the above invocation of <tt>yourshape</tt>
will be preceded by

<PRE><TT>
[ 54 36 0 36 0 0 54 0 54 36 ]  4 true yourshape
</TT></PRE>

where the current color is the node's fillcolor.
<P>
<I>
NOTE: In versions before 23 September 2005,
<tt>yourshape</tt> is only invoked once, with the node's fill value
and with the color set to the node's pencolor.
</I>
<P>
For example, here are the contents of a plausible shape file, <TT>DFD.ps</TT>,
which can be invoked by
<TT>[shape=DFDbox]</TT>

<PRE>
	/xdef {exch def} bind def
	/DFDbox {
		10 dict begin
			/fflag xdef
			/sides xdef
			fflag   % if shape is filled
			{
				aload pop
				newpath
				moveto
				1 1 sides { pop lineto } for
				closepath fill
			}
			{
				aload pop
				% draw the sides
				newpath
				moveto
				1 1 sides {
					2 mod 0 ne
					{moveto} % even sides
					{lineto currentpoint stroke moveto} % odd sides
					ifelse
				} for
            }
			ifelse
		end
	} bind def
</PRE>


A custom shape of this kind is always clipped to its bounding box.
It would not be hard to create a hook in the function <TT>user_shape()</TT>
in <TT>shapes.c</TT> to determine clipping polygons other than rectangles (maybe)
in case someone wants to try this and contribute the code for this.
<P>
Note that, by default, the bounding box is drawn around the contents
and the node label is drawn. If you wish to eliminate these,
set label="" and peripheries=0 in the node. 
<h4> Driver-independent custom shapes </h4>
If not using PostScript, you'll need to roll up your sleeves and
modify the source.  None of the other code generators support custom
node shapes directly, yet.

If the custom shape is to be high-level and driver-independent, then
you can add shape-specific functions (methods) to <TT>shapes.c</TT> with
a corresponding entry in the array <TT>Shapes[]</TT>  that maps
shape names to methods.  The method interfaces are described in the comment
header in this file.
Methods must be defined to initialize a shape (typically to size it big enough
to fit its text label), bind a port name to a coordinate, test if a point
is inside an instance of the shape (for edge clipping), generate code
for the shape via the <TT>CodeGen</TT> functions, and return a box path
to reach ports on the interior of a node (if they can exist).
<p>
This is where you'd implement a shape that can be drawn as
a sequence of strokes, filled paths, and text labels.
<p>
Shapes that behave more or less like polygons can be bootstrapped from
the basic polygon methods; see for example the "invtri" shape.  Such
shapes use a polygon descriptor whose fields are listed below.

<table border cellspacing=0 cellpadding=5>
<caption align=top>Polygon descriptor fields</caption>
<tr align=left><th>regul</th><td> if a regular polygon</td><td>FALSE</td></tr>
<tr align=left><th>perip</th><td> number of border peripheries</td><td>1</td></tr>
<tr align=left><th>sides</th><td> number of sides (1 for curves)</td><td>4</td></tr>
<tr align=left><th>orien</th><td> angular rotation in degrees </td><td>0</td></tr>
<tr align=left><th>disto</th><td>trapezoidal distortion</td><td>0</td></tr>
<tr align=left><th>skew</th><td>parallelogram distortion</td><td>0</td></tr>
<tr align=left><th>flags</th><td>fancy options: ROUNDED, DIAGONALS, AUXLABELS</td><td>0</td></tr>
</table>
<p>
For example shapes not derived from general polygons, see the <TT>record</TT> or <TT>epsf</TT> shape.


<h4> Driver-dependent custom shapes </h4>
To implement a driver-specific shape (such as
<A HREF="http://cloanto.com/users/mcb/19950127giflzw.html">GIF</A> or
<A HREF="http://www.cdrom.com/pub/png/">PNG</A>
icons) you'll need to write a body for the driver function that implements user-defined 
shapes. (The drivers are in <TT>*gen.c</TT>). A user shape function
receives four arguments: <br>
	- the custom shape name string <br>
	- the absolute canvas coords of the shape bounding polygon <br>
	- number of coords (currently, always 4) <br>
	- fill flag <br>
<p>
The rest is up to you, but contact us first just in case.  
(FYI, the 
<A HREF="http://www.graphviz.org/cvs.html">
gv1.6 beta</A> has a compile-time PNG replacement for the GIF driver.)
<P>
<center>
</BODY>
</HTML>
